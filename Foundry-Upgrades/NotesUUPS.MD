## Lesson 13: Foundry Upgrades ‚ú®

Foundry course: FOUNDRY-UPGRADES
5:00:50

## (UUPS) Universal Upgradeable Proxy Standard (Setup) ‚ú®

- In **UUPS proxies** the upgrade is handled by the implementation, and can eventually be removed.
- **UUPS proxies** are implemented using an **ERC1967Proxy**.
  - **EIP-1967: Standard Proxy Storage Slot**
    A consistent location where proxies store the address of the logic contract they delegate to, as well as other proxy-specific information
- **UUPS proxies** es un poco m√°s barato de deployar que **Transparent proxy**

### Empezando a crear los contratos üßë‚Äçüî¨

- Creamos un contrato llamado **BoxV1.sol**

  - Ok, como estamos usando **UUPS proxy**, vaamos a necesitar agregar todo el proxy upgredeability dentro de el contrato **BoxV1.sol**
  - este contrato **BoxV1** es bastante simple y sirve como un contenedor de un n√∫mero entero y una funci√≥n para obtener ese n√∫mero. Tambi√©n tiene una funci√≥n adicional para proporcionar informaci√≥n sobre la versi√≥n del contrato.

- Creamos una funci√≥n llamada **BoxV2.sol**
  - Copiamos y pegamos el contrato **BoxV1** al **BoxV2** y lo cambiamos un poco.
  - Va a retornar el **numero 2** como versi√≥n en la funci√≥n **version()**.
  - Agregamos una funci√≥n nueva llamada **setNumber(unit256 \_number)**

## Vamos a hacer BoxV1 actualizable (Upgradeable) ‚ú®

> üí° Vamos a installar openzeppelin-contracts-upgradeable del repo de openzeppelin, porque necesitamos importar varios archivos que necesitaremos.

- [openzeppelin-contracts-upgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable)

- Lo primero que necesitaremos es importar el **UUPSUpgradeable** contract from **OZ**

### Initializable.sol ‚ú®

- Dado que los contratos proxy **no utilizan un constructor**, es com√∫n trasladar la l√≥gica del constructor a una funci√≥n externa de inicializaci√≥n, generalmente llamada **initialize**. Luego se vuelve necesario proteger esta funci√≥n de inicializaci√≥n para que solo pueda ser llamada una vez. El modificador {**initializer**} proporcionado por este contrato tendr√° este efecto.

> ‚ú®REMEMBER‚ú®: storage is stored in the proxy, Not implementation. Es por esto que los proxies no usasn contructores.
> proxy -> dploy implementation -> call some "initializer" function.

- **\_disableInitializers();** Llamamos a esta funcion en el **constructor()**:
  - Bloquea el contrato, impidiendo cualquier futura reinicializaci√≥n. Esto no puede formar parte de una llamada de inicializador. Llamar a esto en el constructor de un contrato evitar√° que ese contrato se inicialice o reinicialice a cualquier versi√≥n. Se recomienda usar esto para bloquear contratos de implementaci√≥n que est√°n dise√±ados para ser llamados a trav√©s de proxies.

```solidity
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
```
- Ahora agregamos la funcion **initialize()** que ser√° como el **constructor()** que usamos normalmente en los smart contracts. Aqui adentro establecemos lo que queramos inicializar.
- Importamos **OwnableUpgradeable** from **OZ** para poder hacer uso de la funcion **__Ownable_init**
  - Aqu√≠ estamos seteando el **owner** al **msg.sender** es como si hicieramos -> **owner = msg.sender**

- Tambi√©n es muy com√∫n ver **__UUPSUpgradeable_init();** que teor√≠a no hace nada pero es una buena practica agregarlo a la funcion **initialize()**, para decir, **¬°¬°¬°Heyy este es un UUPS contract!!!**

### Arreglando BoxV2 ‚ú®
- En este contrato vamos a hacer un poco lo mismo que en BoxV1. 
- Importamos los archivos **UUPSUpgradeable, Initializable, OwnableUpgradeable de Openzeppelin**. 
> üí°Important: La herencia se debe de hacer por orden alf√°betico.
- Tambi√©n agregamos la funcion **function _authorizeUpgrade(address newImplementation) internal override { }** del archivo **UUPSUpgradeable** De openzeppelin. 
- Tambi√©n agregamos el **constructor** y el **initialize()**

## (UUPS) Universal Upgradeable Proxy Standard (DEPLOY) ‚ú®
- Vamos a **deployar BoxV1**
  -  vamos a obtener un address
  -  vamos a usar ese proxy address para asegurarnos de que nuestras funciones funcionen.

- Luego vamos a **deployar BoxV2** 
  - vamos a apuntar nuestro proxy(**BoxV1**) a **BoxV2**
  - Lo c√∫al esencialmente significa que vamos a actualizar nuestro contrato. Y va a permanecer la misma address.

### Empezando a desarrollar los archivos scripts para deployar nuestros contratos ‚ú®
- Hacemos dos archivos en scripts llamados **DeployBox.s.sol** y **UpgradeBox.s.sol**

#### DeployBox.s.sol üßë‚Äçüî¨
- Importamos BoxV1. 
- Empezamos con la conocida funci√≥n **run()** que va a retornar un **address**
- Creamos una segunda funci√≥n llamada **deployBox()** que retornar√° un **address**
  - Dentro de esta funcion deployamos el **BoxV1**. Que es el **contrato de implementaci√≥n**, el que tiene la l√≥gica.
  - Ahora necesitamos obtener nuestro proxy. El que vamos a usar es -> **ERC1967Proxy** exte proxy es el que apuntar√° a nuestra **implementaci√≥n**.
- **Importamos ERC1967Proxy from Openzeppelin**.
  > import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
- Deployamos **ERC1967Proxy** y le pasamos como parametro el **boxV1 address**.

#### UpgradeBox.s.sol üßë‚Äçüî¨
- Escribimos la funci√≥n **run()** y necesitamos el deployment m√°s reciente. Por eso instalaremos el archivo **DevOpsTools** de cyfrin.
- Importamos **Boxv2.**