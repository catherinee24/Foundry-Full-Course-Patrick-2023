## Lesson 13: Foundry Upgrades âœ¨

Foundry course: FOUNDRY-UPGRADES
5:00:50

## (UUPS) Universal Upgradeable Proxy Standard (Setup) âœ¨

- In **UUPS proxies** the upgrade is handled by the implementation, and can eventually be removed.
- **UUPS proxies** are implemented using an **ERC1967Proxy**.
  - **EIP-1967: Standard Proxy Storage Slot**
    A consistent location where proxies store the address of the logic contract they delegate to, as well as other proxy-specific information
- **UUPS proxies** es un poco mÃ¡s barato de deployar que **Transparent proxy**

### Empezando a crear los contratos ðŸ§‘â€ðŸ”¬

- Creamos un contrato llamado **BoxV1.sol**

  - Ok, como estamos usando **UUPS proxy**, vaamos a necesitar agregar todo el proxy upgredeability dentro de el contrato **BoxV1.sol**
  - este contrato **BoxV1** es bastante simple y sirve como un contenedor de un nÃºmero entero y una funciÃ³n para obtener ese nÃºmero. TambiÃ©n tiene una funciÃ³n adicional para proporcionar informaciÃ³n sobre la versiÃ³n del contrato.

- Creamos una funciÃ³n llamada **BoxV2.sol**
  - Copiamos y pegamos el contrato **BoxV1** al **BoxV2** y lo cambiamos un poco.
  - Va a retornar el **numero 2** como versiÃ³n en la funciÃ³n **version()**.
  - Agregamos una funciÃ³n nueva llamada **setNumber(unit256 \_number)**

## Vamos a hacer BoxV1 actualizable (Upgradeable) âœ¨

> ðŸ’¡ Vamos a installar openzeppelin-contracts-upgradeable del repo de openzeppelin, porque necesitamos importar varios archivos que necesitaremos.

- [openzeppelin-contracts-upgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable)

- Lo primero que necesitaremos es importar el **UUPSUpgradeable** contract from **OZ**

### Initializable.sol âœ¨

- Dado que los contratos proxy **no utilizan un constructor**, es comÃºn trasladar la lÃ³gica del constructor a una funciÃ³n externa de inicializaciÃ³n, generalmente llamada **initialize**. Luego se vuelve necesario proteger esta funciÃ³n de inicializaciÃ³n para que solo pueda ser llamada una vez. El modificador {**initializer**} proporcionado por este contrato tendrÃ¡ este efecto.

> âœ¨REMEMBERâœ¨: storage is stored in the proxy, Not implementation. Es por esto que los proxies no usasn contructores.
> proxy -> dploy implementation -> call some "initializer" function.

- **\_disableInitializers();** Llamamos a esta funcion en el **constructor()**:
  - Bloquea el contrato, impidiendo cualquier futura reinicializaciÃ³n. Esto no puede formar parte de una llamada de inicializador. Llamar a esto en el constructor de un contrato evitarÃ¡ que ese contrato se inicialice o reinicialice a cualquier versiÃ³n. Se recomienda usar esto para bloquear contratos de implementaciÃ³n que estÃ¡n diseÃ±ados para ser llamados a travÃ©s de proxies.

```solidity
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
```
- Ahora agregamos la funcion **initialize()** que serÃ¡ como el **constructor()** que usamos normalmente en los smart contracts. Aqui adentro establecemos lo que queramos inicializar.
- Importamos **OwnableUpgradeable** from **OZ** para poder hacer uso de la funcion **__Ownable_init**
  - AquÃ­ estamos seteando el **owner** al **msg.sender** es como si hicieramos -> **owner = msg.sender**

- TambiÃ©n es muy comÃºn ver **__UUPSUpgradeable_init();** que teorÃ­a no hace nada pero es una buena practica agregarlo a la funcion **initialize()**, para decir, **Â¡Â¡Â¡Heyy este es un UUPS contract!!!**

### Arreglando BoxV2 âœ¨
- En este contrato vamos a hacer un poco lo mismo que en BoxV1. 
- Importamos los archivos **UUPSUpgradeable, Initializable, OwnableUpgradeable de Openzeppelin**. 
> ðŸ’¡Important: La herencia se debe de hacer por orden alfÃ¡betico.
- TambiÃ©n agregamos la funcion **function _authorizeUpgrade(address newImplementation) internal override { }** del archivo **UUPSUpgradeable** De openzeppelin. 
- TambiÃ©n agregamos el **constructor** y el **initialize()**

## (UUPS) Universal Upgradeable Proxy Standard (DEPLOY) âœ¨
- Vamos a **deployar BoxV1**
  -  vamos a obtener un address
  -  vamos a usar ese proxy address para asegurarnos de que nuestras funciones funcionen.

- Luego vamos a **deployar BoxV2** 
  - vamos a apuntar nuestro proxy(**BoxV1**) a **BoxV2**
  - Lo cÃºal esencialmente significa que vamos a actualizar nuestro contrato. Y va a permanecer la misma address.

### Empezando a desarrollar los archivos scripts para deployar nuestros contratos âœ¨
- Hacemos dos archivos en scripts llamados **DeployBox.s.sol** y **UpgradeBox.s.sol**

#### DeployBox.s.sol
- Importamos BoxV1. 
- Empezamos con la conocida funciÃ³n **run()** que va a retornar un **address**
- Creamos una segunda funciÃ³n llamada **deployBox()** que retornarÃ¡ un **address**
  - Dentro de esta funcion deployamos el **BoxV1**. Que es el **contrato de implementaciÃ³n**, el que tiene la lÃ³gica.
  - Ahora necesitamos obtener nuestro proxy. El que vamos a usar es -> **ERC1967Proxy**