## Lesson 13: Foundry Upgrades ‚ú®

Foundry course: FOUNDRY-UPGRADES
5:00:50

## (UUPS) Universal Upgradeable Proxy Standard (Setup) ‚ú®

- In **UUPS proxies** the upgrade is handled by the implementation, and can eventually be removed.
- **UUPS proxies** are implemented using an **ERC1967Proxy**.
  - **EIP-1967: Standard Proxy Storage Slot**
    A consistent location where proxies store the address of the logic contract they delegate to, as well as other proxy-specific information
- **UUPS proxies** es un poco m√°s barato de deployar que **Transparent proxy**

### Empezando a crear los contratos üßë‚Äçüî¨

- Creamos un contrato llamado **BoxV1.sol**

  - Ok, como estamos usando **UUPS proxy**, vaamos a necesitar agregar todo el proxy upgredeability dentro de el contrato **BoxV1.sol**
  - este contrato **BoxV1** es bastante simple y sirve como un contenedor de un n√∫mero entero y una funci√≥n para obtener ese n√∫mero. Tambi√©n tiene una funci√≥n adicional para proporcionar informaci√≥n sobre la versi√≥n del contrato.

- Creamos una funci√≥n llamada **BoxV2.sol**
  - Copiamos y pegamos el contrato **BoxV1** al **BoxV2** y lo cambiamos un poco.
  - Va a retornar el **numero 2** como versi√≥n en la funci√≥n **version()**.
  - Agregamos una funci√≥n nueva llamada **setNumber(unit256 \_number)**

## Vamos a hacer BoxV1 actualizable (Upgradeable) ‚ú®

> üí° Vamos a installar openzeppelin-contracts-upgradeable del repo de openzeppelin, porque necesitamos importar varios archivos que necesitaremos.

- [openzeppelin-contracts-upgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable)

- Lo primero que necesitaremos es importar el **UUPSUpgradeable** contract from **OZ**

### Initializable.sol ‚ú®

- Dado que los contratos proxy **no utilizan un constructor**, es com√∫n trasladar la l√≥gica del constructor a una funci√≥n externa de inicializaci√≥n, generalmente llamada **initialize**. Luego se vuelve necesario proteger esta funci√≥n de inicializaci√≥n para que solo pueda ser llamada una vez. El modificador {**initializer**} proporcionado por este contrato tendr√° este efecto.

> ‚ú®REMEMBER‚ú®: storage is stored in the proxy, Not implementation. Es por esto que los proxies no usasn contructores.
> proxy -> dploy implementation -> call some "initializer" function.

- **\_disableInitializers();** Llamamos a esta funcion en el **constructor()**:
  - Bloquea el contrato, impidiendo cualquier futura reinicializaci√≥n. Esto no puede formar parte de una llamada de inicializador. Llamar a esto en el constructor de un contrato evitar√° que ese contrato se inicialice o reinicialice a cualquier versi√≥n. Se recomienda usar esto para bloquear contratos de implementaci√≥n que est√°n dise√±ados para ser llamados a trav√©s de proxies.

```solidity
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
```
- Ahora agregamos la funcion **initialize()** que ser√° como el **constructor()** que usamos normalmente en los smart contracts. Aqui adentro establecemos lo que queramos inicializar.
- Importamos **OwnableUpgradeable** from **OZ** para poder hacer uso de la funcion **__Ownable_init**
  - Aqu√≠ estamos seteando el **owner** al **msg.sender** es como si hicieramos -> **owner = msg.sender**

- Tambi√©n es muy com√∫n ver **__UUPSUpgradeable_init();** que teor√≠a no hace nada pero es una buena practica agregarlo a la funcion **initialize()**, para decir, **¬°¬°¬°Heyy este es un UUPS contract!!!**

### Arreglando BoxV2 ‚ú®
- En este contrato vamos a hacer un poco lo mismo que en BoxV1. 
- Importamos los archivos **UUPSUpgradeable, Initializable, OwnableUpgradeable de Openzeppelin**. 
> üí°Important: La herencia se debe de hacer por orden alf√°betico.
- Tambi√©n agregamos la funcion **function _authorizeUpgrade(address newImplementation) internal override { }** del archivo **UUPSUpgradeable** De openzeppelin. 
- Tambi√©n agregamos el **constructor** y el **initialize()**